"""Tests for ripping business logic (no hardware required)."""
import os
import unittest.mock

import pytest


class TestJobState:
    """Test JobState enum and status sets."""

    def test_success_value(self):
        from arm.models.job import JobState
        assert JobState.SUCCESS.value == "success"

    def test_failure_value(self):
        from arm.models.job import JobState
        assert JobState.FAILURE.value == "fail"

    def test_idle_value(self):
        from arm.models.job import JobState
        assert JobState.IDLE.value == "active"

    def test_ripping_value(self):
        from arm.models.job import JobState
        assert JobState.VIDEO_RIPPING.value == "ripping"

    def test_transcoding_value(self):
        from arm.models.job import JobState
        assert JobState.TRANSCODE_ACTIVE.value == "transcoding"

    def test_finished_set(self):
        from arm.models.job import JobState, JOB_STATUS_FINISHED
        assert JobState.SUCCESS in JOB_STATUS_FINISHED
        assert JobState.FAILURE in JOB_STATUS_FINISHED
        assert JobState.IDLE not in JOB_STATUS_FINISHED

    def test_ripping_set(self):
        from arm.models.job import JobState, JOB_STATUS_RIPPING
        assert JobState.VIDEO_RIPPING in JOB_STATUS_RIPPING
        assert JobState.AUDIO_RIPPING in JOB_STATUS_RIPPING
        assert JobState.IDLE not in JOB_STATUS_RIPPING

    def test_transcoding_set(self):
        from arm.models.job import JobState, JOB_STATUS_TRANSCODING
        assert JobState.TRANSCODE_ACTIVE in JOB_STATUS_TRANSCODING
        assert JobState.TRANSCODE_WAITING in JOB_STATUS_TRANSCODING
        assert JobState.IDLE not in JOB_STATUS_TRANSCODING


class TestRipData:
    """Test rip_data() data disc ripping logic."""

    def test_duplicate_label_gets_unique_filename(self, app_context, sample_job, tmp_path):
        """Second data disc with same label should NOT overwrite the first (#1651)."""
        from arm.ripper.utils import rip_data

        raw = tmp_path / "raw"
        completed = tmp_path / "completed"
        raw.mkdir()
        completed.mkdir()

        sample_job.disctype = "data"
        sample_job.label = "MYDATA"
        sample_job.video_type = "unknown"
        sample_job.config.RAW_PATH = str(raw)
        sample_job.config.COMPLETED_PATH = str(completed)

        # First rip: create the raw directory so the second call thinks it's a collision
        (raw / "MYDATA").mkdir()

        with unittest.mock.patch('arm.ripper.utils.subprocess.check_output') as mock_dd, \
             unittest.mock.patch('arm.ripper.utils.shutil.move') as mock_move:
            mock_dd.return_value = b""
            rip_data(sample_job)

            # shutil.move should have been called with a timestamped .iso filename
            assert mock_move.called, "shutil.move was never called"
            final_file = mock_move.call_args[0][1]  # full_final_file
            # The ISO filename should NOT be just "MYDATA.iso" — it should have a suffix
            assert os.path.basename(final_file) != "MYDATA.iso"

    def test_unique_label_uses_plain_filename(self, app_context, sample_job, tmp_path):
        """Data disc with unique label uses plain label as filename."""
        from arm.ripper.utils import rip_data

        raw = tmp_path / "raw"
        completed = tmp_path / "completed"
        raw.mkdir()
        completed.mkdir()

        sample_job.disctype = "data"
        sample_job.label = "UNIQUE_DISC"
        sample_job.video_type = "unknown"
        sample_job.config.RAW_PATH = str(raw)
        sample_job.config.COMPLETED_PATH = str(completed)

        with unittest.mock.patch('arm.ripper.utils.subprocess.check_output') as mock_dd, \
             unittest.mock.patch('arm.ripper.utils.shutil.move') as mock_move:
            mock_dd.return_value = b""
            rip_data(sample_job)

            assert mock_move.called, "shutil.move was never called"
            final_file = mock_move.call_args[0][1]
            assert final_file.endswith("UNIQUE_DISC.iso")


class TestRipMusic:
    """Test rip_music() audio CD ripping logic."""

    def test_abcde_error_in_log_detected(self, app_context, sample_job, tmp_path):
        """abcde exit 0 with [ERROR] in log should be treated as failure (#1526)."""
        from arm.ripper.utils import rip_music

        sample_job.disctype = "music"
        sample_job.config.LOGPATH = str(tmp_path)

        # Write a log file with abcde error markers
        logfile = "test_music.log"
        (tmp_path / logfile).write_text(
            "Grabbing track 01...\n"
            "[ERROR] cdparanoia could not read disc\n"
            "CDROM drive unavailable\n"
        )

        with unittest.mock.patch('arm.ripper.utils.subprocess.check_output', return_value=b""), \
             unittest.mock.patch('arm.ripper.utils.cfg') as mock_cfg:
            mock_cfg.arm_config = {"ABCDE_CONFIG_FILE": "/nonexistent"}
            result = rip_music(sample_job, logfile)

        assert result is False
        assert sample_job.status == "fail"

    def test_abcde_clean_log_succeeds(self, app_context, sample_job, tmp_path):
        """abcde exit 0 with clean log should be treated as success."""
        from arm.ripper.utils import rip_music

        sample_job.disctype = "music"
        sample_job.config.LOGPATH = str(tmp_path)

        logfile = "test_music.log"
        (tmp_path / logfile).write_text(
            "Grabbing track 01...\n"
            "Grabbing track 02...\n"
            "Finished.\n"
        )

        with unittest.mock.patch('arm.ripper.utils.subprocess.check_output', return_value=b""), \
             unittest.mock.patch('arm.ripper.utils.cfg') as mock_cfg:
            mock_cfg.arm_config = {"ABCDE_CONFIG_FILE": "/nonexistent"}
            result = rip_music(sample_job, logfile)

        assert result is True

    def test_abcde_nonzero_exit_detected(self, app_context, sample_job, tmp_path):
        """abcde with non-zero exit code should be caught."""
        import subprocess
        from arm.ripper.utils import rip_music

        sample_job.disctype = "music"
        sample_job.config.LOGPATH = str(tmp_path)

        with unittest.mock.patch('arm.ripper.utils.subprocess.check_output',
                                 side_effect=subprocess.CalledProcessError(1, "abcde", b"error")), \
             unittest.mock.patch('arm.ripper.utils.cfg') as mock_cfg:
            mock_cfg.arm_config = {"ABCDE_CONFIG_FILE": "/nonexistent"}
            result = rip_music(sample_job, "test.log")

        assert result is False


class TestMakemkvDiscDiscovery:
    """Test MakeMKV disc number discovery guard (#1545)."""

    def test_mdisc_none_no_drives_raises(self, app_context, sample_job):
        """When job.drive is None and get_drives yields nothing, raise ValueError."""
        from arm.ripper.makemkv import makemkv

        # Ensure no SystemDrives linked
        assert sample_job.drive is None

        with unittest.mock.patch('arm.ripper.makemkv.prep_mkv'), \
             unittest.mock.patch('arm.ripper.makemkv.get_drives', return_value=iter([])):
            with pytest.raises(ValueError, match="No MakeMKV disc number"):
                makemkv(sample_job)

    def test_mdisc_none_drive_exists_but_mdisc_null_raises(self, app_context, sample_job):
        """When job.drive exists but mdisc is None, and scan finds no match, raise ValueError."""
        from arm.models.system_drives import SystemDrives
        from arm.database import db
        from arm.ripper.makemkv import makemkv

        # Create a SystemDrives row linked to this job, but mdisc=None
        drive = SystemDrives()
        drive.mount = sample_job.devpath
        drive.job_id_current = sample_job.job_id
        drive.mdisc = None
        db.session.add(drive)
        db.session.commit()
        db.session.refresh(sample_job)
        assert sample_job.drive is not None
        assert sample_job.drive.mdisc is None

        with unittest.mock.patch('arm.ripper.makemkv.prep_mkv'), \
             unittest.mock.patch('arm.ripper.makemkv.get_drives', return_value=iter([])):
            with pytest.raises(ValueError, match="No MakeMKV disc number"):
                makemkv(sample_job)

    def test_mdisc_populated_skips_scan(self, app_context, sample_job, tmp_path):
        """When job.drive.mdisc is already set, skip disc:9999 scan entirely."""
        from arm.models.system_drives import SystemDrives
        from arm.database import db
        from arm.ripper.makemkv import makemkv

        # Create a SystemDrives row with mdisc already populated
        drive = SystemDrives()
        drive.mount = sample_job.devpath
        drive.job_id_current = sample_job.job_id
        drive.mdisc = 0
        db.session.add(drive)
        db.session.commit()
        db.session.refresh(sample_job)

        mock_get_drives = unittest.mock.MagicMock()

        with unittest.mock.patch('arm.ripper.makemkv.prep_mkv'), \
             unittest.mock.patch('arm.ripper.makemkv.get_drives', mock_get_drives), \
             unittest.mock.patch('arm.ripper.makemkv.setup_rawpath', return_value=str(tmp_path)), \
             unittest.mock.patch('arm.ripper.makemkv.makemkv_mkv'), \
             unittest.mock.patch.object(sample_job, 'eject'), \
             unittest.mock.patch('arm.ripper.makemkv._reconcile_filenames'), \
             unittest.mock.patch.object(sample_job, 'build_raw_path', return_value='raw'):
            makemkv(sample_job)

        # get_drives should NOT have been called — mdisc was already set
        mock_get_drives.assert_not_called()
