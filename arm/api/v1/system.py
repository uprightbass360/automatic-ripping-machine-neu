"""API v1 â€” System endpoints."""
import os
import platform
import subprocess

import psutil
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse

import arm.config.config as cfg
from arm.database import db
from arm.models.app_state import AppState
from arm.services import jobs as svc_jobs

router = APIRouter(prefix="/api/v1", tags=["system"])


def _detect_cpu() -> str:
    """Detect CPU model name from /proc/cpuinfo (Linux) or platform fallback."""
    try:
        with open("/proc/cpuinfo") as f:
            for line in f:
                if line.startswith("model name"):
                    return line.split(":", 1)[1].strip()
    except OSError:
        pass
    return platform.processor() or "Unknown"


@router.get('/system/info')
def get_system_info():
    """Return static hardware identity (CPU model, total RAM). No DB access."""
    mem = psutil.virtual_memory()
    return {
        "cpu": _detect_cpu(),
        "memory_total_gb": round(mem.total / 1073741824, 1),
    }


@router.post('/system/restart')
def restart():
    """Restart the ARM UI service."""
    return svc_jobs.restart_ui()


@router.get('/system/stats')
def get_system_stats():
    """Return live system metrics: CPU, memory, and disk usage."""
    cpu_percent = psutil.cpu_percent()
    cpu_temp = 0.0
    try:
        temps = psutil.sensors_temperatures()
        for key in ('coretemp', 'cpu_thermal', 'k10temp'):
            if temps.get(key):
                cpu_temp = temps[key][0].current
                break
    except (AttributeError, OSError):
        pass

    mem = psutil.virtual_memory()
    memory = {
        "total_gb": round(mem.total / 1073741824, 1),
        "used_gb": round(mem.used / 1073741824, 1),
        "free_gb": round(mem.available / 1073741824, 1),
        "percent": mem.percent,
    }

    media_paths = [
        ("Raw", cfg.arm_config.get("RAW_PATH", "")),
        ("Transcode", cfg.arm_config.get("TRANSCODE_PATH", "")),
        ("Completed", cfg.arm_config.get("COMPLETED_PATH", "")),
    ]
    storage = []
    for name, path in media_paths:
        if not path:
            continue
        try:
            usage = psutil.disk_usage(path)
            storage.append({
                "name": name,
                "path": path,
                "total_gb": round(usage.total / 1073741824, 1),
                "used_gb": round(usage.used / 1073741824, 1),
                "free_gb": round(usage.free / 1073741824, 1),
                "percent": usage.percent,
            })
        except FileNotFoundError:
            continue

    return {
        "cpu_percent": cpu_percent,
        "cpu_temp": cpu_temp,
        "memory": memory,
        "storage": storage,
    }


@router.get('/system/ripping-enabled')
def get_ripping_enabled():
    """Return whether ripping is currently enabled (not paused)."""
    state = AppState.get()
    return {"ripping_enabled": not state.ripping_paused}


@router.get('/system/version')
def get_version():
    """Return ARM and MakeMKV versions."""
    import re

    arm_version = "unknown"
    install_path = cfg.arm_config.get("INSTALLPATH", "")
    version_file = os.path.join(install_path, "VERSION")
    try:
        with open(version_file) as f:
            arm_version = f.read().strip()
    except OSError:
        pass

    makemkv_version = "unknown"
    try:
        result = subprocess.run(
            ["makemkvcon", "-r", "info", "dev:/dev/null"],
            capture_output=True, text=True, timeout=10
        )
        m = re.search(r'MakeMKV v([\d.]+)', result.stdout + result.stderr)
        if m:
            makemkv_version = m.group(1)
    except Exception:
        pass

    return {
        "arm_version": arm_version,
        "makemkv_version": makemkv_version,
    }


@router.get('/system/paths')
def get_paths():
    """Check existence and writability of configured ARM paths."""
    path_keys = [
        "RAW_PATH", "COMPLETED_PATH", "TRANSCODE_PATH",
        "LOGPATH", "DBFILE", "INSTALLPATH",
    ]
    results = []
    for key in path_keys:
        value = cfg.arm_config.get(key, "")
        if not value:
            continue
        exists = os.path.exists(value)
        writable = os.access(value, os.W_OK) if exists else False
        results.append({
            "setting": key,
            "path": value,
            "exists": exists,
            "writable": writable,
        })
    return results


@router.post('/system/ripping-enabled')
async def set_ripping_enabled(request: Request):
    """Toggle global ripping pause."""
    body = await request.json()
    if 'enabled' not in body:
        return JSONResponse(
            {"success": False, "error": "'enabled' field required"},
            status_code=400,
        )

    state = AppState.get()
    state.ripping_paused = not bool(body['enabled'])
    db.session.commit()

    return {
        "success": True,
        "ripping_enabled": not state.ripping_paused,
    }
